> There is an old saying, "If a worker wants to do a good job, he must first use a sharp tool", "Sharpen a knife without accidentally chopping wood"...


In order to let every user (especially Xiaobai) try to avoid stepping on pits and save more time, hereby summarizes a guide to avoid pits. Before officially using EE, you might as well spend three or five minutes to learn it, which can help you avoid pitfalls in use. Step on the pit, thus saving a lot of time.

1. ES version and SpringBoot version<br />Because we use ES's official RestHighLevelClient at the bottom, we have requirements for the ES version. The version of RestHighLevelClient used at the bottom is 7.10, so the compatibility with 7.10 is the best. At present, ES has been measured. Version 7.x can be perfectly compatible.<br />The version of Springboot used at the bottom is 2.5.4, so we recommend that users use the version of springboot to use 2.5.4. Since we have few modules that depend on Springboot, the actual measurement is 2.3. Springboot of .x-2.6.x can be perfectly compatible. The lower or higher version is not tested. Users can test it by themselves. We do not know what version of springboot2.5.4 can be backward and upward compatible. In short, it is recommended as much as possible. Consistent with the built-in version of the framework.

2. The keyword type and text type of the ES index
> If you already know the ES index type, you can skip this introduction directly.

The keyword type in ES is basically the same as the field in MySQL. When we need to perform exact matching, left fuzzy, right fuzzy, full fuzzy, sorting aggregation and other operations on the query field, the index type of the field needs to be keyword type. Otherwise, you will find that the query does not find the desired result, or even reports an error. For example, APIs commonly used in EE, such as eq(), like(), distinct(), etc., all require the field type to be keyword type.

When we need to perform word segmentation query on a field, we need the type of the field to be text type, and specify the tokenizer (use the ES default tokenizer if not specified, the effect is usually not ideal). For example, the API match() commonly used in EE, etc. The field type needs to be text type. When the expected result is not queried when using the match query, you can check the index type first, and then check the tokenizer, because if a word is not separated by the tokenizer, the result cannot be queried.

When the same field, we need to use it as both the keyword type and the text type. At this time, our index type is the keyword_text type. In EE, you can add the annotation @TableField(fieldType = FieldType.KEYWORD_TEXT to the field) ), so the field will be created as a keyword+text double type as shown in the figure below. It is worth noting that when we query this field as a keyword type, ES requires the incoming field name to be "field name.keyword" , when querying the field as a text type, you can directly use the original field name.

![image2](https://iknow.hs.net/72818af6-7cc3-4833-b7a7-dbff845ce73e.png)

Another way is, you can redundant a field, the value is the same, one annotation is marked as keyword type, the other is marked as text type, and the corresponding field is selected according to the rules for query when querying.


It should also be noted that if the index type of a field is created to query only the keyword type (as shown in the figure below), you do not need to append .keyword to its name, and you can query it directly.

![image3](https://iknow.hs.net/87335e55-1fe3-44ed-920b-61354383e85a.png)


3. Field id

Since many functions of the framework are implemented with the help of id, such as selectById, update, deleteById..., and there must be a column in ES as the data id, we force the entity class encapsulated by the user to include the field id column, otherwise the framework will not Some functions cannot be used normally.
````java
public class Document {
    /**
     * The unique id in es, if you want to customize the id provided by the id in es, such as the id in MySQL, please specify the type in the annotation as customize or specify it directly in the global configuration file, so the id supports any data type)
     */
    @TableId(type = IdType.CUSTOMIZE)
    private String id;
}
````
If the @TableId annotation is not added or the annotation is added but the type is not specified, the id defaults to the id automatically generated by es.

When calling the insert method, if the id data does not exist in es, the data will be added. If the id data already exists, even if you call the insert method, the actual effect is to update the data corresponding to the id. This needs to be distinguished from MP and MySQL.

4. Use of and and or

It needs to be different from MySQL and MP, because the query parameter of ES is a tree data structure, which is different from MySQL tiling. For details, please refer to the [and&or](and-or.md) chapter for detailed savings.


I will talk about so much about closing the pit for the time being. If there is any supplement, I will add it later. I wish you all a happy use. If you have any questions or suggestions during the use process, you can add my WeChat 252645816 feedback. We also have a special Q&A group to provide free services for you .